#!/usr/bin/env python

import logging
log = logging.getLogger('alpaca')
log.setLevel(logging.DEBUG)
fh = logging.FileHandler('alpaca.log')
fh.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
ff = logging.Formatter('[%(asctime)s] %(levelname)s :: %(message)s')
cf = logging.Formatter('[%(levelname)s] %(message)s')
fh.setFormatter(ff)
ch.setFormatter(cf)
log.addHandler(fh)
log.addHandler(ch)

from pathlib import Path
import datetime

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
from sklearn.metrics import roc_curve, auc
from progressbar import progressbar

from alpaca.colalola import CoLaLoLa


class BatchManager:

    def __init__(self, sig_path):
        self._labeledjets = self.get_jets(sig_path)
        log.info('Nr. of signal events: %s', len(self._labeledjets))

    @staticmethod
    def get_jets(file_path):
        """
        The returned object looks like this:

        [[[event 1 jet 1 t, event 1 jet 1 x, event 1 jet 1 y, event 1 jet 1 z, event 1 jet 1 partonindex]
          [event 1 jet 2 t, event 1 jet 2 x, event 1 jet 2 y, event 1 jet 2 z, event 1 jet 2 partonindex]
            ...
          [event 1 jet 10 t, event 1 jet 10 x, event 1 jet 10 y, event 1 jet 10 z, event 1 jet 10 partonindex]]
          [[event 2 jet 1 t, event 2 jet 1 x, event 2 jet 1 y, event 1 jet 1 z, event 2 jet 1 partonindex]
          [event 2 jet 2 t, event 2 jet 2 x, event 2 jet 2 y, event 1 jet 2 z, event 2 jet 2 partonindex]
           ...

        basically they are separated by events. For each event they are
        separated by jet: jet 1, jet 2, etc. And for each jet the five elements
        are the four coordinates of the TLorentz vector: t, x, y, z.
        The jets are zero-padded up to 10
        """

        df = pd.read_hdf(file_path,"df")
        nevents = len(df)
        # The input rows have all jet px, all jet py, ... all jet partonindex
        # So segment and swap axes to group by jet
        jet_stack = np.swapaxes(df.values.reshape(nevents,5,10),1,2)

        return jet_stack

    def get_torch_batch(self, N, start_index=0):
        stop_index = start_index + N
        if stop_index > len(self._labeledjets):
            log.warning('The stop index is grater than the size of the array')
        jets = self._labeledjets[start_index:stop_index,:,:4]
        labels = self._labeledjets[start_index:stop_index,:,-1:]/6
        leadinglabel = labels[:,0]
        leadingfromtop = leadinglabel>0

        X = torch.as_tensor(jets, dtype=torch.float)
        Y = torch.as_tensor(leadingfromtop, dtype=torch.float)
        return X, Y


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='ML top-like tagger.')
    parser.add_argument('--sig', required=True, type=Path,
                        help='path to the file with sig events')
    parser.add_argument('--quick-test', action='store_true',
                        help='set params for a quick test')
    parser.add_argument('--output-dir', type=Path, default=Path('data'),
                        help='path to the output directory')
    parser.add_argument('--tag', nargs='?', const='',
                        help='tag the output')
    args = parser.parse_args()

    if args.quick_test:
        args.tag = 'test'

    output_dir = args.output_dir
    if args.tag is not None:
        now = datetime.datetime.now()
        if args.tag:
            new_dir_name = '{:%Y%m%d_%H%M%S}_{}'.format(now, args.tag)
        else:
            new_dir_name = '{:%Y%m%d_%H%M%S}'.format(now)
        output_dir = output_dir / new_dir_name
        output_dir.mkdir(parents=True, exist_ok=True)

        nfh = logging.FileHandler(str(output_dir / 'alpaca.log'))
        nfh.setLevel(logging.DEBUG)
        nfh.setFormatter(ff)
        log.addHandler(nfh)

    output_dir.mkdir(parents=True, exist_ok=True)

    log.debug('Signal input: %s', args.sig)
    bm = BatchManager(sig_path=args.sig)

    nobjects = 10
    ncombos = 30
    log.debug('CoLaLoLa: nr. jets %s - nr. combos %s', nobjects, ncombos)
    model = CoLaLoLa(nobjects, ncombos)
    opt = torch.optim.Adam(model.parameters())
    losses = []

    nr_train = 5
    batch_size = 500
    # No stats right now
    # if args.quick_test:
    #     nr_train = 5
    #     batch_size = 500
    log.debug('Training: %s iterations - batch size %s', nr_train, batch_size)
    for i in progressbar(range(nr_train)):
        model.train()
        opt.zero_grad()

        X, Y = bm.get_torch_batch(batch_size, start_index=i * batch_size)
        P = model(X)
        P, Y = P, Y.reshape(-1, 1)

        loss = torch.nn.functional.binary_cross_entropy(P, Y)
        losses.append(float(loss))
        #if i % 25 == 0:
        #    print(loss)
        #    #plt.plot(losses)
        #    #plt.show()
        loss.backward()
        opt.step()

    log.debug('Finished training')
    fig = plt.figure()
    plt.plot(losses)
    plt.savefig(str(output_dir / 'losses.png'))

    log.info('Save plot model')
    fig = plt.figure()
    plt.imshow(model.cola.w_combo.data.numpy())
    plt.savefig(str(output_dir / 'w_combo.png'))

    log.info('Make torch batch')
    X,Y = bm.get_torch_batch(2500, nr_train * batch_size)
    P = model(X)

    _P = P.data.numpy()
    _Y = Y.data.numpy()

    log.info('Plot Histograms')
    fig = plt.figure()
    plt.hist(_P[_Y==0],
             bins = np.linspace(0, 1, 50),
             label='ISR jet',
             density=True,
             histtype='step')
    plt.hist(_P[_Y==1],
             bins = np.linspace(0, 1, 50),
             label='Top jet',
             density=True,
             histtype='step')
    #plt.semilogy()
    plt.legend()
    plt.savefig(str(output_dir / 'score.png'))

    log.info('Plot ROC curve')
    fpr, tpr, thr = roc_curve(_Y, _P)
    roc_auc = auc(fpr, tpr)
    print(len(fpr))
    print(max(fpr))
    print(fpr[-10:])
    print(len(_P))

    fig = plt.figure()
    plt.plot(fpr, tpr, color='darkorange',
             label='ROC curve (area = {:.2f})'.format(roc_auc))
    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    #plt.title('Receiver operating characteristic')
    plt.legend(loc="lower right")
    plt.savefig(str(output_dir / 'roc_curve.png'))

    # w = model.cola.w_combo.data.numpy()
    # fig = plt.figure()
    # plt.hist(X.data.numpy()[Y==0, :, 1].ravel(), bins=100)
    #
    # plt.savefig(str(output_dir / 'ravel.png'))
    #
    # X.data.numpy()[Y==0, :, 1]

    #log.info('Make torch batch')
    #X, Y = bm.get_torch_batch(500, nr_train * batch_size)
    #np.unique(X[Y==1].data.numpy()[:, :, 0].ravel()).shape
    #fig = plt.figure()
    #_,b,_ = plt.hist(X[Y==1].data.numpy()[:, :, 0].ravel(),bins=100);
    #plt.hist(X[Y==0].data.numpy()[:, :, 0].ravel(),bins=b);
    #plt.savefig('data/ravel_2.png')
