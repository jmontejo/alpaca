#!/usr/bin/env python

import logging
import os

from pathlib import Path
import datetime

import numpy as np
import torch
from progressbar import progressbar

import matplotlib.pyplot as plt

import alpaca.log
from alpaca.batch import BatchManager2HDM

logging.getLogger('matplotlib').setLevel(logging.WARNING)

log = logging.getLogger('alpaca')


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='ML top-like tagger.')
    parser.add_argument('--input-file', '-i', required=True, type=Path,
                        help='path to the file with the input events')
    parser.add_argument('--output-dir', type=Path, default=Path('data'),
                        help='path to the output directory')
    parser.add_argument('--tag', default='alpaca',
                        help='tag the output')
    parser.add_argument('--shuffle-jets', action='store_true',
                        help='reorder jets in each event')
    parser.add_argument('--shuffle-events', action='store_true',
                        help='reorder events in the dataset')
    parser.add_argument('--simple-nn', action='store_true',
                        help=('substitute a simple feed-forward NN for '
                              'colalola'))
    parser.add_argument('--hydra', action='store_true',
                        help='a colalola network with multiple output heads')
    parser.add_argument('--alt-loss', action='store_true',
                        help='try a different loss function')
    parser.add_argument("--fflayers", nargs="+", type=int, default=[200])
    parser.add_argument("--ncombos", type=int, default=30)
    parser.add_argument("--one-loss", help="use one single loss value",choices=["ISR","lep0top","lep1top","had0top"])
    parser.add_argument("--weights", default="1,1,1,1",help="weight for each component, format \"a,b,c,d\"")


    args = parser.parse_args()
    weights = [float(w) for w in args.weights.split(",")]
    weights = [w/sum(weights) for w in weights] 

    assert len(weights)==4, weights

    # Autogenerate meaningful names for outputf dir
    output_dir = args.output_dir
    new_dir_name = args.tag
    if args.shuffle_jets:
        new_dir_name += "_shuffled"
    else:
        new_dir_name += "_ptordered"
    if args.simple_nn:
        new_dir_name += "_simplenn"
    elif args.hydra:
        new_dir_name += "_hydra"
    if args.alt_loss:
        new_dir_name += "_altloss"
    if args.one_loss:
        new_dir_name += "_oneloss"+args.one_loss
    new_dir_name += "_{}combos".format(args.ncombos)
    layerstr = '_'.join([str(i) for i in args.fflayers])
    new_dir_name += "_" + layerstr

    output_dir = output_dir / new_dir_name
    output_dir.mkdir(parents=True, exist_ok=True)

    alpaca.log.setup_logger(file_path=output_dir / 'alpaca.log')
    log.debug('Alpaca has been started and can finally log')
    log.debug(args)
    log.debug('Input file: %s', args.input_file)

    log.info('Writing to dir: %s', new_dir_name)

    njets = 7
    bm = BatchManager2HDM(
        input_path=args.input_file,
        shuffle_jets=args.shuffle_jets,
        shuffle_events=args.shuffle_events,
        jets_per_event=njets,
        zero_jets=2 # padding one of the seven jet
    )
    log.info('Nr. of events: %s', bm.get_nr_events())

    noutputs = njets*4
    if args.simple_nn:
        from alpaca.nn.simple import SimpleNN
        log.info('SimpleNN: nr. jets %s', njets)
        log.info('  FeedForwardHead intermediate layers: [%s]',
                 layerstr.replace('_', ','))
        model = SimpleNN(njets+3, noutputs, fflayers=args.fflayers)
    elif args.hydra:
        from alpaca.nn.hydra import Hydra
        log.info('CoLaLoLa with multiple heads: nr. jets %s - nr. combos %s',
                 njets, args.ncombos)
        log.info('  FeedForwardHead intermediate layers: [%s]',
                 layerstr.replace('_', ','))
        model = Hydra(njets+3, args.ncombos, fflayers=args.fflayers)
    else:
        # Plain CoLaLoLa as default
        from alpaca.nn.colalola import CoLaLoLa
        log.info('CoLaLoLa: nr. jets %s - nr. combos %s', njets,
                 args.ncombos)
        log.info('  FeedForwardHead intermediate layers: [%s]',
                 layerstr.replace('_', ','))
        model = CoLaLoLa(njets+3, args.ncombos, noutputs,
                         fflayers=args.fflayers)

    opt = torch.optim.Adam(model.parameters())
    losses = {"total": [], "ISR": [], "lep0top": [], "lep1top": [], "had0top": []}
    if args.alt_loss:
        losses.update({"penalty_ISR": [], "penalty_lep0top": []})

    #nr_train = 315
    #batch_size = 315
    #test_sample = 8000
    nr_train = 43
    batch_size = 100
    test_sample = 1000
    log.info('Training: %s iterations - batch size %s', nr_train, batch_size)
    for i in progressbar(range(nr_train)):
        model.train()
        opt.zero_grad()

        X, Y = bm.get_torch_batch(batch_size, start_index=i * batch_size + test_sample)
        P = model(X)
        Y = Y.reshape(-1, noutputs)
        P_ISR, Y_ISR = P[:, :njets], Y[:, :njets] #njets flags for ISR or not
        P_lep0top, Y_lep0top = P[:, njets:njets*2], Y[:, njets:njets*2]
        P_lep1top, Y_lep1top = P[:, njets*2:njets*3], Y[:, njets*2:njets*3]
        P_had0top, Y_had0top = P[:, njets*3:njets*4], Y[:, njets*3:njets*4]

        loss = {
            "ISR": torch.nn.functional.binary_cross_entropy(P_ISR, Y_ISR),
            "lep0top": torch.nn.functional.binary_cross_entropy(P_lep0top, Y_lep0top),
            "lep1top": torch.nn.functional.binary_cross_entropy(P_lep1top, Y_lep1top),
            "had0top": torch.nn.functional.binary_cross_entropy(P_had0top, Y_had0top),
        }
        loss["total"] = loss["ISR"]*weights[0] + loss["lep0top"]*weights[1] + loss["lep1top"]*weights[2] + loss["had0top"]*weights[3]
        if args.one_loss:
            loss["total"] = loss[args.one_loss]
        if args.alt_loss:
            loss["penalty_ISR"] = P_ISR[Y_ISR == 0].mean() + \
                                  (1 - P_ISR[Y_ISR == 1]).mean()
            loss["penalty_lep0top"] = P_lep0top[Y_lep0top == 0].mean() + \
                                    (1 - P_lep0top[Y_lep0top == 1]).mean()
            loss["total"] += loss["penalty_ISR"] + loss["penalty_lep0top"]

        for key, val in loss.items():
            losses[key].append(float(val))
        loss["total"].backward()
        opt.step()

    log.debug('Finished training')

    fig = plt.figure()
    for losstype, lossvals in losses.items():
        plt.plot(lossvals, label=losstype)
    plt.legend()
    plt.savefig(str(output_dir / 'losses.png'))

    pred  = {"ISR": {}, "lep0top": {}, "lep1top": {}, "had0top": {}}
    truth = {"ISR": {}, "lep0top": {}, "lep1top": {}, "had0top": {}}
    jets = {}

    def fill_arrays(batch, label, model, filter_6j=False):
        X, Y = batch
        if filter_6j:
            mask = (X[:, :, 3] > 0).sum(1) == 6
            nsel = np.count_nonzero(mask)
            X = X[mask].reshape(nsel, X.shape[1], X.shape[2])
            Y = Y[mask].reshape(nsel, Y.shape[1])

        x = X.data.numpy()
        jets[label] = x
        #
        y = Y.data.numpy()
        p = model(X).data.numpy()
        # Alternatively, can split up the model output
        pred["ISR"][label] = p[:, :njets]
        pred["lep0top"][label] = p[:, njets:njets*2]
        pred["lep1top"][label] = p[:, njets*2:njets*3]
        pred["had0top"][label] = p[:, njets*3:njets*4]
        #
        truth["ISR"][label]   = y[:, :njets]
        truth["lep0top"][label] = y[:, njets:njets*2]
        truth["lep1top"][label]  = y[:, njets*2:njets*3]
        truth["had0top"][label] = y[:, njets*3:njets*4]

    log.info('Extracting test sample')
    fill_arrays(
        bm.get_torch_batch(
            test_sample,
            start_index=0
        ),
        "Test",
        model
    )
    log.info(len(jets["Test"]))
    log.info('Sampling predictions for training sample')
    fill_arrays(
        bm.get_torch_batch(
            test_sample,
            start_index=test_sample
        ),
        "Train",
        model
    )
    log.info(len(jets["Train"]))

    bm_6j = BatchManager2HDM(
        input_path=args.input_file,
        shuffle_jets=args.shuffle_jets,
        shuffle_events=args.shuffle_events,
        jets_per_event=njets,
        zero_jets=1, # padding one of the seven jet
        all_partons_included=False,
    )
    log.info('Extracting sample of events with exactly 6 jets')
    # sample from the last events of the 39k 6-jet events
    fill_arrays(
        bm_6j.get_torch_batch(
            5000,
            start_index=0
        ),
        "6-jet",
        model
    )
    log.info(len(jets["6-jet"]))

    # Flatten & save numpy arrays
    flatdict = {}
    for sample in ["Test", "Train", "6-jet"]:
        flatdict["jets_{}".format(sample)] = jets[sample]
        for discr in ["ISR", "lep0top", "lep1top","had0top"]:
            flatdict["pred_{}_{}".format(discr, sample)] = pred[discr][sample]
            flatdict["truth_{}_{}".format(discr, sample)] = truth[discr][sample]
    np.savez(str(output_dir / "data.npz"), **flatdict)

    #cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --do-chi2 --output-dir {out}".format(out=output_dir)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out}".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --allow-2jet".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --normalize-scores".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --normalize-scores-ISR".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --exclude-highest-ISR".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --exclude-highest-ISR --normalize-scores".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --exclude-highest-ISR --normalize-scores-ISR".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --normalize-scores --allow-2jet".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --normalize-scores-ISR --allow-2jet".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --exclude-highest-ISR --allow-2jet".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --exclude-highest-ISR --normalize-scores --allow-2jet".format(out=output_dir)
    os.system(cmd)
    cmd = "chi2_bench.py --xsttbar-dir ${{ALPACA_DIR}} --npz {out}/data.npz --output-dir {out} --exclude-highest-ISR --normalize-scores-ISR --allow-2jet".format(out=output_dir)
    os.system(cmd)

    from alpaca.plot import *
    log.info('Plot combination weights')
    if args.simple_nn:
        # No cola plots
        pass
    elif args.hydra:
        plot_hydra_weights(model, output_dir)
    else:
        plot_cola_weights(model, output_dir)

    log.info('Plot scores and ROC curves for ISR matching')
    plot_score_roc(
        pred,
        truth,
        "ISR",
        output_dir,
        plotlabels=("Jets matched to hard scatter", "Jets not matched to hard scatter"),
        irange=range(njets)
    )

    log.info('Plot scores and ROC curves for lep0top matching')
    plot_score_roc(
        pred,
        truth,
        "lep0top",
        output_dir,
        plotlabels=("Jets matched to leading lepton", "Jets not matched to leading lepton"),
        irange=range(njets)
    )


    log.info('Plot scores and ROC curves for lep1top identification')
    plot_score_roc(
        pred,
        truth,
        "lep1top",
        output_dir,
        plotlabels=("Jets matched to subleading lepton", "Jets not matched to subleading lepton"),
        irange=range(njets)
    )

    log.info('Plot scores and ROC curves for had0top identification')
    plot_score_roc(
        pred,
        truth,
        "had0top",
        output_dir,
        plotlabels=("Jets matched to hadronic top", "Jets not matched to hadronic top"),
        irange=range(njets)
    )

    log.info('Plot scores for jets from tops 1 and 2')
    #plot_topmatch(pred, truth, output_dir)
    if njets > 6:
        log.info('Plot scores and ROC curves for ISR-tagging')
        plot_score_roc(
            pred,
            truth,
            "ISR",
            output_dir,
            plotlabels=("Top jet", "ISR jet"),
            irange=range(njets)
        )

        log.info('Plot score for true ISR jet')
        plot_true_ISR(pred, truth, output_dir)

        log.info('Plot index of ISR jet')
        plot_index_ISR(pred, truth, output_dir)
