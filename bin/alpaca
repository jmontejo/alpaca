#!/usr/bin/env python

import logging
log = logging.getLogger('alpaca')
log.setLevel(logging.DEBUG)
fh = logging.FileHandler('alpaca.log')
fh.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
ff = logging.Formatter('[%(asctime)s] %(levelname)s :: %(message)s')
cf = logging.Formatter('[%(levelname)s] %(message)s')
fh.setFormatter(ff)
ch.setFormatter(cf)
log.addHandler(fh)
log.addHandler(ch)

from pathlib import Path
import datetime

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import torch
from sklearn.metrics import roc_curve, auc
from progressbar import progressbar

from alpaca.colalola import CoLaLoLa


class BatchManager:

    def __init__(self, sig_path, shuffle_jets=False, shuffle_events=False):
        self._labeledjets = self.get_jets(sig_path, shuffle_jets, shuffle_events)
        log.info('Nr. of signal events: %s', len(self._labeledjets))

    @staticmethod
    def get_jets(file_path,shuffle_jets=False,shuffle_events=False):
        """
        The returned object looks like this:

        [[[event 1 jet 1 t, event 1 jet 1 x, event 1 jet 1 y, event 1 jet 1 z, event 1 jet 1 partonindex]
          [event 1 jet 2 t, event 1 jet 2 x, event 1 jet 2 y, event 1 jet 2 z, event 1 jet 2 partonindex]
            ...
          [event 1 jet 10 t, event 1 jet 10 x, event 1 jet 10 y, event 1 jet 10 z, event 1 jet 10 partonindex]]
          [[event 2 jet 1 t, event 2 jet 1 x, event 2 jet 1 y, event 1 jet 1 z, event 2 jet 1 partonindex]
          [event 2 jet 2 t, event 2 jet 2 x, event 2 jet 2 y, event 1 jet 2 z, event 2 jet 2 partonindex]
           ...

        basically they are separated by events. For each event they are
        separated by jet: jet 1, jet 2, etc. And for each jet the five elements
        are the four coordinates of the TLorentz vector: t, x, y, z; plus a
        truth-based parton label (0=not top jet, 1-3 = b,Wa,Wb from top, 4-6
        ditto from antitop).
        The jets are zero-padded up to the 10th and pT-ordered.
        """

        df = pd.read_hdf(file_path,"df")
        if shuffle_events:
            df.reindex(np.random.permutation(df.index))
        nevents = len(df)
        # The input rows have all jet px, all jet py, ... all jet partonindex
        # So segment and swap axes to group by jet
        jet_stack = np.swapaxes(df.values.reshape(nevents,5,10),1,2)
        if shuffle_jets:
            # shuffle only does the outermost level
            # iterate through rows to shuffle each event individually
            for row in jet_stack:
                np.random.shuffle(row)
        return jet_stack

    def get_torch_batch(self, N, nlabels, start_index=0):
        stop_index = start_index + N
        if stop_index > len(self._labeledjets):
            log.warning('The stop index is greater than the size of the array')
        jets = self._labeledjets[start_index:stop_index,:,:4]
        labels = self._labeledjets[start_index:stop_index,:nlabels,-1:]
        # is the jet from the ttbar system?
        jetfromttbar = labels > 0
        # is the jet associated with the top quark?
        # Disregard the jets that are from ISR
        # Account for charge ambiguity by identifying whether the
        # jets match the leading jet or not
        maskedlabels = np.ma.masked_where(jetfromttbar==False,labels)
        nonisrlabels = np.array([r.compressed() for r in maskedlabels])
        topmatch = np.array( [ r>3 if r[0]>3 else r<3 for r in nonisrlabels] )
        jetlabels = np.concatenate([jetfromttbar.squeeze(),topmatch],1)

        X = torch.as_tensor(jets, dtype=torch.float)
        Y = torch.as_tensor(jetlabels, dtype=torch.float)
        return X, Y


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='ML top-like tagger.')
    parser.add_argument('--sig', required=True, type=Path,
                        help='path to the file with sig events')
    parser.add_argument('--quick-test', action='store_true',
                        help='set params for a quick test')
    parser.add_argument('--output-dir', type=Path, default=Path('data'),
                        help='path to the output directory')
    parser.add_argument('--tag', nargs='?', const='',
                        help='tag the output')
    parser.add_argument('--shuffle-jets', action='store_true',
                        help='reorder jets in each event')
    parser.add_argument('--shuffle-events', action='store_true',
                        help='reorder events in the dataset')
    args = parser.parse_args()

    if args.quick_test:
        args.tag = 'test'

    output_dir = args.output_dir
    if args.tag is not None:
        now = datetime.datetime.now()
        if args.tag:
            new_dir_name = args.tag
        else:
            new_dir_name = '{:%Y%m%d_%H%M%S}'.format(now)
        output_dir = output_dir / new_dir_name
        output_dir.mkdir(parents=True, exist_ok=True)

        nfh = logging.FileHandler(str(output_dir / 'alpaca.log'))
        nfh.setLevel(logging.DEBUG)
        nfh.setFormatter(ff)
        log.addHandler(nfh)

    output_dir.mkdir(parents=True, exist_ok=True)

    log.debug('Signal input: %s', args.sig)
    bm = BatchManager(sig_path=args.sig, shuffle_jets=args.shuffle_jets, shuffle_events=args.shuffle_events)

    nobjects = 10
    ncombos = 30
    njets = 10
    ntomatch = 6
    noutputs = njets + ntomatch
    log.debug('CoLaLoLa: nr. jets %s - nr. combos %s', nobjects, ncombos)
    model = CoLaLoLa(nobjects, ncombos, noutputs)
    opt = torch.optim.Adam(model.parameters())
    losses = []

    nr_train = 500
    batch_size = 500
    # No stats right now
    if args.quick_test:
        nr_train = 100
        batch_size = 100
    log.debug('Training: %s iterations - batch size %s', nr_train, batch_size)
    for i in progressbar(range(nr_train)):
        model.train()
        opt.zero_grad()

        X, Y = bm.get_torch_batch(batch_size, nlabels=noutputs, start_index=i * batch_size)
        P = model(X)
        P, Y = P, Y.reshape(-1, noutputs)

        loss = torch.nn.functional.binary_cross_entropy(P, Y)
        losses.append(float(loss))
        #if i % 25 == 0:
        #    print(loss)
        #    #plt.plot(losses)
        #    #plt.show()
        loss.backward()
        opt.step()

    log.debug('Finished training')
    fig = plt.figure()
    plt.plot(losses)
    plt.savefig(str(output_dir / 'losses.png'))

    log.info('Save plot model')
    fig = plt.figure()
    plt.imshow(model.cola.w_combo.data.numpy())
    plt.savefig(str(output_dir / 'w_combo.png'))

    log.info('Make torch batch')
    X,Y = bm.get_torch_batch(50000, nr_train * batch_size)
    P = model(X)

    _P = P.data.numpy()
    _Y = Y.data.numpy().squeeze()

    log.info('Plot Histograms and ROC curves for ISR-tagging')
    for ijet in range(njets):
        _Pjet = _P[:,ijet]
        _Yjet = _Y[:,ijet]
        fig = plt.figure()
        plt.hist(_Pjet[_Yjet==0],
                 bins = np.linspace(0, 1, 50),
                 label='ISR jet',
                 density=True,
                 histtype='step')
        plt.hist(_Pjet[_Yjet==1],
                 bins = np.linspace(0, 1, 50),
                 label='Top jet',
                 density=True,
                 histtype='step')
        #plt.semilogy()
        plt.legend()
        plt.savefig(str(output_dir / 'score_ISR_jet{}.png'.format(ijet)))
        plt.close()

        fpr, tpr, thr = roc_curve(_Yjet, _Pjet)
        roc_auc = auc(fpr, tpr)

        fig = plt.figure()
        plt.plot(fpr, tpr, color='darkorange',
                 label='ROC curve (area = {:.2f})'.format(roc_auc))
        plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.05])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        #plt.title('Receiver operating characteristic')
        plt.legend(loc="lower right")
        plt.savefig(str(output_dir / 'roc_curve_ISR_jet{}.png'.format(ijet)))
        plt.close()

    log.info('Plot Histograms and ROC curves for top/tbar matching')
    for ijet in range(ntomatch):
        _Pjet = _P[:,ijet+10]
        _Yjet = _Y[:,ijet+10]
        fig = plt.figure()
        plt.hist(_Pjet[_Yjet==0],
                 bins = np.linspace(0, 1, 50),
                 label='Top jet',
                 density=True,
                 histtype='step')
        plt.hist(_Pjet[_Yjet==1],
                 bins = np.linspace(0, 1, 50),
                 label='Antitop jet',
                 density=True,
                 histtype='step')
        #plt.semilogy()
        plt.legend()
        plt.savefig(str(output_dir / 'score_ttbar_jet{}.png'.format(ijet)))
        plt.close()

        fpr, tpr, thr = roc_curve(_Yjet, _Pjet)
        roc_auc = auc(fpr, tpr)

        fig = plt.figure()
        plt.plot(fpr, tpr, color='darkorange',
                 label='ROC curve (area = {:.2f})'.format(roc_auc))
        plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.05])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        #plt.title('Receiver operating characteristic')
        plt.legend(loc="lower right")
        plt.savefig(str(output_dir / 'roc_curve_ttbar_jet{}.png'.format(ijet)))
        plt.close()

    # w = model.cola.w_combo.data.numpy()
    # fig = plt.figure()
    # plt.hist(X.data.numpy()[Y==0, :, 1].ravel(), bins=100)
    #
    # plt.savefig(str(output_dir / 'ravel.png'))
    #
    # X.data.numpy()[Y==0, :, 1]

    #log.info('Make torch batch')
    #X, Y = bm.get_torch_batch(500, nr_train * batch_size)
    #np.unique(X[Y==1].data.numpy()[:, :, 0].ravel()).shape
    #fig = plt.figure()
    #_,b,_ = plt.hist(X[Y==1].data.numpy()[:, :, 0].ravel(),bins=100);
    #plt.hist(X[Y==0].data.numpy()[:, :, 0].ravel(),bins=b);
    #plt.savefig('data/ravel_2.png')
